\documentclass[article,shortnames]{jss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Brandon Whitcher\\GlaxoSmithKline \And 
        Volker J. Schmid\\Ludwig-Maximilians Universit\"at M\"unchen \And
        Andrew Thornton\\???}
\title{Working with the {DICOM} and {NIfTI} Data Standards in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Brandon Whitcher, Volker Schmid, Andrew Thornton} %% comma-separated
\Plaintitle{Working with the {DICOM} and {NIfTI} Data Standards in R} %% without formatting
\Shorttitle{{DICOM} and {NIfTI} in R} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  The abstract of the article.
}
\Keywords{keywords, comma-separated, not capitalized, \proglang{R}}
\Plainkeywords{keywords, comma-separated, not capitalized, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Brandon Whitcher\\
  GlaxoSmithKline\\
  Clinical Imaging Centre\\
  Hammersmith Hospital\\
  Du Cane Road\\
  London W12 0HS, United Kingdom\\
  E-mail: \email{bjw34032@users.sourceforge.net}\\
  URL: \url{http://rigorousanalytics.blogspot.com/}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<preliminaries,echo=FALSE,results=hide>>=
library("oro.dicom")
library("bitops")
library("XML")
library("oro.nifti")
options(width=80)
options(prompt="R> ")
@

\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section[]{Introduction}



\section[oro.dicom: DICOM Data Input/Output in R]{\pkg{oro.dicom}: DICOM Data Input/Output in \proglang{R}}

The industry standard format, for data acquired using a clinical
imaging device, is DICOM (Digital Imaging and Communications in
Medicine; \url{medical.nema.org}).  The DICOM ``standard'' is very
broad and complex.  Roughly speaking each DICOM-compliant file is a
collection of fields organized into two four-byte sequences
(group,element) that are represented as hexadecimal numbers and form a
tag.  The (group,element) combination establishes what type of
information is forthcoming in the file.  There is no fixed number of
bytes for a DICOM header.  The final (group,element) tag should be the
``data'' tag (7FE0,0010), such that all subsequent information is
related to the image(s).

\subsection[]{The DICOM Header}

Accessing the information stored in a single DICOM file is enabled
using the \code{dicomInfo} function.  The basic structure of the
resulting object is a list with two elements: the DICOM header
(\code{hdr}) and the DICOM image (\code{img}).  The header information
is organized in a data frame with six columns and an unknown number of
rows depending on the input parameters.

<<DICOM Abdo 01>>=
abdo <- dicomInfo(system.file("dcm/Abdo.dcm", package="oro.dicom"))
names(abdo)
abdo$hdr[1:5,]
abdo$hdr[nrow(abdo$hdr)-4:0,]
@ 

The ordering of the rows is identical to the ordering in the original
DICOM file.  Hence, the first five tags in the DICOM header of
\code{Abdo.dcm} are: ``GroupLength'', ``FileMetaInformationVersion'',
``MediaStorageSOPClassUID'', ``MediaStorageSOPInstanceUID'' and
``TransferSyntaxUID''.  The last five tags in the DICOM header are
also shown, with the very last tag indicating the start of the image
data for that file and the number of bytes (131072) involved.  When
additional tags in the DICOM header information are queried

<<DICOM Abdo 02>>=
abdo$hdr$value[abdo$hdr$name %in% "BitsAllocated"]
abdo$hdr$value[abdo$hdr$name %in% "Rows"]
abdo$hdr$value[abdo$hdr$name %in% "Columns"]
@ 

it is clear that the data are consistent with the header information
in terms of number of bytes ($256\times256\times2=131072$).

The first five columns are taken directly from the DICOM header
information (\code{group}, \code{element}, \code{code}, \code{length}
and \code{value}) or inferred from that information (\code{name}).
Note, the (\code{group},\code{element}) values are stored as character
strings even though they are hexadecimal numbers.  All aspects of the
data frame may be interrogated in \proglang{R} in order to extract
relevant information from the DICOM header; e.g.,
\code{"BitsAllocated"} as above.

When multiple DICOM files are located in a single directory, or spread
across multiple directories in a tree, the function
\code{dicomSeparate} is used.  

<<DICOM HK40 01>>=
hk40 <- dicomSeparate(system.file("hk-40", package="oro.dicom"))
c(length(hk40$hdr), length(hk40$img))
@ 

The object associated with \code{dicomSeparate} is now a nested set of
lists, where the \code{hdr} is a list of data frames and the
\code{img} is a list of matrices.  These two lists are associated in a
pairwise sense; i.e., \code{hdr[[1]]} is the header information for
the image \code{img[[1]]}.  Default parameters \code{recursive = TRUE}
and \code{pixelData = TRUE} (which is actually an input parameter for
\code{dicomInfo}) allow the user to search down all possible
subdirectories and upload the image in addition to the header
information, respectively.  Also, by default all files are treated as
DICOM files unless the \code{exclude} parameter is set to the unwanted
file extension; e.g., \code{exclude = "xml"}.

\subsection[]{The DICOM Image}

Most DICOM files involve a single slice from an acquisition -- the
image.  Going back to the \code{Abdo.dcm} example, the image is
accessed via

<<figure1-png,echo=FALSE,results=hide>>=
png(filename="dicom_abdo.png", width=400, height=400, bg="black")
par(mar=rep(0,4))
@ 
<<figure1-code>>=
image(t(abdo$img), col=grey(0:64/64), axes=FALSE, xlab="", ylab="")
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
#par(mar=c(5,4,4,2)+0.1)
@ 

where the transpose function is necessary for proper visualization of
the image.  Figure~\ref{fig:dicom_abdo} displays a coronal slice
through the abdomen from an MRI acquisition.  All formatting
information should accompany the image through the DICOM header, and
this information is utiilized as much as possible by \pkg{oro.dicom}
to simplify the manipulation of DICOM data.  

\begin{figure}[!htbp]
  \centering
  \includegraphics*[width=0.5\textwidth]{dicom_abdo.png}
  \caption{Coronal slice of the abdomen viewed in neurological
    convention (left is right and right is left).}
  \label{fig:dicom_abdo}
\end{figure}



\section[oro.nifti: NIfTI-1 Data Input/Output in R]{\pkg{oro.nifti}: NIfTI-1 Data Input/Output in \proglang{R}}

Although the industry standard for medical imaging data is DICOM,
another format has come to be heavily used in the image analysis
community.  The ANALYZE format was originally developed in conjunction
with an image processing system (of the same name) at the Mayo
Foundation.  An Anlayze (7.5) format image is comprised of two files,
the ``hdr'' and ``img'' files, that contain information about the
acquisition and the acquisition itself, respectively.  A more recent
adaption of this format is known as NIfTI-1 and is a product of the
Data Format Working Group (DFWG) from the Neuroimaging Informatics
Technology Initiative (NIfTI; \url{nifti.nimh.nih.gov}).  The NIfTI-1
data format is almost identical to the ANALYZE format, but offers a
few improvements: merging of the header and image information into one
file (.nii), re-organization of the 348-byte fixed header into more
relevant categories and the possibility of extending the header
information.

\subsection[]{A Note on Axes and Orientation}

The NIfTI format contains an implicit generalized spatial
transformation from the data co-ordinate system $(i,j,k)$ into a
real-space ``right-handed'' co-ordinate system.  In this real-space
system, the $(x,y,z)$ axes are \emph{usually} set such that $x$
increases from left to right, $y$ increases from posterior to anterior
and $z$ increases from inferior to superior.

At this point in time the \pkg{oro.nifti} package cannot apply an
arbitrary transform to the imaging data into $(x,y,z)$ space -- such a
transform may require non-integral indices and interpolation steps.
The package does accommodate straightforward transformations of imaging
data; e.g., setting the $x$-axis to increase from right to left
(neurological).  Future versions of \pkg{oro.nifti} will attempt to
address more complicated transformations.

\subsection[]{NIfTI and ANALYZE data in S4}

A major improvement in the \pkg{oro.nifti} package is the fact that
standard medical imaging formats are stored in unique classes under
the S4 system \citep{chambers:2008}.  Essentially, NIfTI and ANALYZE
data are stored as multi-dimensional arrays with extra slots created
that capture the format-specific header information.  The NIfTI class
also has the ability to read and write extensions that conform to the
data format standard.  Customized printing and validity-checking
functions are available to the user and every attempt is made to
ensure that the information from the multi-dimensional array is in
agreement with the header values.

\subsection[]{Audit Trail}

Following on from the S4 implementation of both the NIfTI and Analyze
data formats, the ability to extend the NIfTI data format header is
utilized in the \pkg{oro.nifti} package.  First, extensions are
properly handled when reading and writing NIfTI data.  Second, users
are allowed to add extensions to newly-created NIfTI objects using
various functions and the \pkg{XML} package \citep{XML}.  Third, by
default all operations that are performed on a NIfTI object will
generate what we call an \emph{audit trail} that consists of an
XML-based log.  Each log entry contains information not only about the
function applied to the NIfTI object, but also various system-level
information; e.g., version of \proglang{R}, user name, date, time,
etc.  When writing NIfTI-class objects to disk, the XML-based NIfTI
extension is converted into plain text and saved appropriately (ecode
= 6).  The user may control the tracking of data manipulation via the
audit trail using a global option.  For example please use the command

<<niftiAuditTrail,eval=FALSE>>=
options(niftiAuditTrail=FALSE)
@

to turn off the ``audit trail'' option in \pkg{oro.nifti}.

Interactive visualization of multidimensional arrays, stored in NIfTI
or Analyze format, is best performed outside of \proglang{R} at this
point in time.  Popular viewers, especially for brain imaging, are
\begin{itemize}
\item FSLView (\url{http://www.fmrib.ox.ac.uk/fsl/fslview/})
\item MRIcroN (\url{http://www.sph.sc.edu/comd/rorden/MRicron/})
\end{itemize}

\subsection[]{Examples}

\subsubsection[]{Labelled LR Standard (MNI152) Images in NIfTI Format}

The first example of reading in, and displaying, medical imaging data
in NIfTI format (\texttt{avg152T1\_LR\_nifti.nii.gz}) was obtained
from the NIfTI website (\url{nifti.nimh.nih.gov/nifti-1/}).  
Successful execution of the command:

<<mniLR_nifti>>=
(mni.LR <- readNIfTI(system.file("nifti/mniLR.nii.gz", package="oro.nifti")))
audit.trail(mni.LR)
descrip(mni.LR)
@ 
<<figure1-png,echo=FALSE,results=hide>>=
png(filename="mniLR.png", width=400, height=400, bg="black")
@ 
<<figure1-code>>=
image(mni.LR)
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data, with the default NIfTI axes,
and is displayed on a $10{\times}10$ grid of images
(Figure~\ref{fig:avg152T1_LR_nifti}).  Note, the \code{image} function
has been modified to accept \code{nifti} and \code{anlz} objects and
display them with minimal user input.  Two accessor functions are also
shown here: \code{audit.trail} and \code{descrip}.  The former is used
to access the XML-based audit trail that is stored as a NIfTI header
extension and the latter is the name of a valid NIfTI header field
(allowed to store up to 80 characters).

\begin{figure}[!htbp]
  \centering
  \includegraphics{mniLR.png}
  \caption{Axial slices of MNI volume \texttt{mniLR\_nifti} stored in
    radiological convention.}
  \label{fig:avg152T1_LR_nifti}
\end{figure}

The second example of reading in, and displaying, medical imaging data
in NIfTI format (\texttt{avg152T1\_RL\_nifti.nii}) was also obtained
from the NIfTI website (\url{nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the command

<<mniRL_nifti>>=
(mni.RL <- readNIfTI(system.file("nifti/mniRL.nii.gz", package="oro.nifti")))
@ 
<<figure2-png,echo=FALSE,results=hide>>=
png(filename="mniRL.png", width=400, height=400, bg="black")
@ 
<<figure2-code>>=
image(mni.RL)
<<figure2-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data that may be displayed in a
$10{\times}10$ grid of images (Figure~\ref{fig:avg152T1_RL_nifti}).

\begin{figure}[!htbp]
  \centering
  \includegraphics{mniRL.png}
  \caption{Axial slices of MNI volume \texttt{avg152T1\_RL\_nifti}
  stored in neurological convention.}
  \label{fig:avg152T1_RL_nifti}
\end{figure}

The first image (LR) is stored in radiological convention.  The second
image (RL) is stored in neurological convention.  Any NIfTI-1 compliant
viewing software should display these images identically.

\subsubsection[]{Simple Time-series or Multi-volume Image}

This is an example of reading in, and displaying, a four-dimensional
medical imaging data set in NIfTI format
(\texttt{filtered\_func\_data.nii}) obtained from the NIfTI website
(\url{nifti.nimh.nih.gov/nifti-1/}).  Successful execution of the
command

<<filtered_func_data>>=
(ffd <- readNIfTI(system.file("nifti/ffd.nii.gz", package="oro.nifti")))
@ 
<<figure3-png,echo=FALSE,results=hide>>=
png(filename="ffd.png", width=400, height=400, bg="black")
@ 
<<figure3-code>>=
image(ffd)
@ 
<<figure3-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a four-dimensional (4D) array of imaging data that may be
displayed in a $5{\times}5$ grid of images (Figure~\ref{fig:ffd}).
The first three dimensions are spatial locations of the voxel (volume
element) and the fourth dimension is time.

\begin{figure}[!htbp]
  \centering
  \includegraphics{ffd.png}
  \caption{Axial slices of the functional MRI ``volume''
  \texttt{filtered\_func\_data} from the first acquisition.}
  \label{fig:ffd}
\end{figure}

An additional graphical display function has been added for
\code{nifti} and \code{anlz} objects that allows orthographic displays.

<<figure3b-png,echo=FALSE,results=hide>>=
png(filename="ffd_orthographic.png", width=400, height=400, bg="black")
@ 
<<figure3b-code>>=
orthographic(ffd)
@ 
<<figure3b-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

\begin{figure}[!htbp]
  \centering
  \includegraphics{ffd_orthographic.png}
  \caption{Orthographic display of the first volume from the
  functional MRI dataset \texttt{filtered\_func\_data}.  By default
  the mid-axial, mid-saggittal and mid-coronal planes are chosen.}
  \label{fig:ffd-orthographic}
\end{figure}

\subsubsection[]{Statistic Image}

This is an example of reading in and displaying a statistical image so
that it may be overlayed on the EPI (echo planar imaging) data taken
from the functional MRI experiment.  The original NIfTI files
(\texttt{filtered\_func\_data.nii} and \texttt{zstat1.nii}) were
obtained from the NIfTI website (\url{nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the command

<<zstat1>>=
(zstat1 <- readNIfTI(system.file("nifti/zstat1.nii.gz", package="oro.nifti")))
@ 
<<figure4-png,echo=FALSE,results=hide>>=
png("ffd_zstat1.png", width=400, height=400, bg="black")
@ 
<<figure4-code>>=
overlay(ffd, ifelse(abs(zstat1) > 5, zstat1, NA), zlim.y=range(zstat1))
<<figure4-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 
produces a 4D array of parameter estimates (essentially coefficients
from a linear regression performed at each voxel) that may be
overlayed on the original data for anatomical reference
(Figure~\ref{fig:zstat1}).  The function \code{overlay} extends the
capabilities of displaying ``images'' by allowing one to add a
statistical image to an underlying structural image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \centering
  \includegraphics{ffd_zstat1.png}
  \caption{Axial slices of the functional MRI data with 
  with the statistical image overlayed.  The test statistics were
  thresholded at $|Z|\geq{5}$.}
  \label{fig:zstat1}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section[]{Converting DICOM to NIfTI}

The \pkg{oro.nifti} package requires incoming data to be in the
ANALYZE~7.5 or NIfTI formats.  Data acquisition and conversion from
DICOM must be performed by the user before the package \pkg{oro.nifti}
may be used to manipulate the imaging data.  Several standalone
software packages allow DICOM-to-NIfTI (or ANALYZE) conversion; e.g.,
\begin{itemize}
\item FreeSurfer (\url{surfer.nmr.mgh.harvard.edu})
\item Xmedcon (\url{xmedcon.sourceforge.net})
\item MRIConvert (\url{lnci.oregon.edu/\~jolinda/MRIConvert})
\end{itemize}
This is by no means an exhaustive list of standalone software packages
available for DICOM conversion.  In addition there are several
\proglang{R} packages with the ability to process DICOM data
\begin{itemize}
\item \pkg{fmri}
\item \pkg{tractor.base} (part of the tractor project
  \url{code.google.com/p/tractor})
\end{itemize}
and facilitate their conversion to ANALYZE or NIfTI format.

\section[]{Conclusion}

\section*{Acknowledgments}

The authors would like to thank...

\bibliography{dicom_nifti}

\end{document}
