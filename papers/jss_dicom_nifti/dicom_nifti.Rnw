\documentclass[article,shortnames]{jss}

\usepackage{rotating}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Brandon Whitcher\\GlaxoSmithKline \And 
        Volker J. Schmid\\Ludwig-Maximilians Universit\"at M\"unchen \And
        Andrew Thornton\\Cardiff University}
\title{Working with the {DICOM} and {NIfTI} Data Standards in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Brandon Whitcher, Volker Schmid, Andrew Thornton} %% comma-separated
\Plaintitle{Working with the {DICOM} and {NIfTI} Data Standards in R} %% without formatting
\Shorttitle{{DICOM} and {NIfTI} in R} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{

Two packages (\pkg{oro.dicom} and \pkg{oro.nifti}) are provided for
the manipulation of medical imaging data that conform to the DICOM
standard or ANALYZE/NIfTI formats.  DICOM data, from a single file or
single directory or directory tree, may be uploaded into \proglang{R}
using basic data structures: a data frame for the header information
and a matrix for the image data.  A list structure is used to organize
multiple DICOM files.  The S4 class framework is used to develop basic
ANALYZE and NIfTI classes, where NIfTI extensions may be used to
extend the fixed-byte NIfTI header.  One example of this, that has
been implemented, is an XML-based ``audit trail'' that tracks the
history of operations applied to a dataset.  The conversion from DICOM
to ANALYZE/NIfTI is straightforward using the capabilities of both
packages.  The S4 classes have been developed to provide a
user-friendly interface to the ANALYZE/NIfTI data formats; allowing
easy data input, data output, image processing and visualization.

}
\Keywords{keywords, comma-separated, not capitalized, \proglang{R}}
\Plainkeywords{keywords, comma-separated, not capitalized, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Brandon Whitcher\\
  GlaxoSmithKline Clinical Imaging Centre\\
  Hammersmith Hospital\\
  Du Cane Road\\
  London W12 0HS, United Kingdom\\
  E-mail: \email{bjw34032@users.sourceforge.net}\\
  URL: \url{http://rigorousanalytics.blogspot.com/}\\
  
  Volker J. Schmid\\
  Bioimaging group\\
  Department of Statistics\\
  Ludwig-Maximilians Universit\"at M\"unchen\\
  Germany\\
  E-mail: \email{volker.schmid@lmu.de}\\
  URL: \url{http://volkerschmid.de}\\
  
  Andrew Thornton\\
  
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<preliminaries,echo=FALSE,results=hide>>=
library("oro.dicom")
library("bitops")
library("XML")
library("splines")
library("oro.nifti")
options(width=76)
options(prompt="R> ")
@

\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section{Introduction}

Medical imaging is well established in both the clinical and research
arenas with numerous equipment manufacturers supplying a wide variety
of modalities.  The DICOM standard was developed from earlier
standards and released in 1993.  It is the data format for clinical
imaging equipment, and other equipment that is beyond the scope of
this work.  The DICOM standard provides interoperability across
hardware, but was not designed to facilitate efficient data
manipulation and image processing.

The ANALYZE format was developed at the Mayo Clinic (in the 1990s) to
store multidimensional biomedical images.  It is fundamentally
different from the DICOM standard since it groups all images from a
single acquisition (typically three- or four-dimensional) into a pair
of binary files, one containing header information and one containing
the image information.  The DICOM standard groups the header and image
information, typically a single two-dimensional image, into a single
file.  Hence, a single acquisition will contain multiple DICOM files
but only a pair of ANALYZE files.

The NIfTI format was developed in the early 2000s by the DFWG (Data
Format Working Group) in an effort to improve upon the ANALYZE format.
The resulting NIfTI-1 format adheres to the basic header/image
combination from the ANALYZE format, but allows the pair of files to
be combined into a single file and re-defines the header fields.

The material presented here provides users with a method of
interacting with DICOM, ANALYZE and NIfTI files in \proglang{R}
\citep{R}.  Real-world datasets, that are publically available, are
used to illustrate the basic functionality of the two packages:
\pkg{oro.dicom} and \pkg{oro.nifti}.  Major featuers include data
input/output, visualization and conversion from DICOM to
ANALYZE/NIfTI.

\section[oro.dicom: DICOM Data Input/Output in R]{\pkg{oro.dicom}: DICOM Data Input/Output in \proglang{R}}

The industry standard format, for data acquired using a clinical
imaging device, is DICOM (Digital Imaging and Communications in
Medicine; \url{http://medical.nema.org}).  The DICOM ``standard'' is
very broad and complex.  Roughly speaking each DICOM-compliant file is
a collection of fields organized into two four-byte sequences
(group,element) that are represented as hexadecimal numbers and form a
tag.  The (group,element) combination establishes what type of
information is forthcoming in the file.  There is no fixed number of
bytes for a DICOM header.  The final (group,element) tag should be the
``data'' tag (7FE0,0010), such that all subsequent information is
related to the image(s).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!htpb]
  \begin{center}
    \begin{tabular}{llrr}
      \hline
      \textbf{Code} & \textbf{Name} & \textbf{Bytes} & \textbf{Fixed}\\
      \hline\\
      AE & ApplicationEntity & 16 & 0\\
      AS & AgeString & 4 & 1\\
      AT & AttributeTag & 4 & 1\\
      CS & CodeString & 16 & 0\\
      DA & Date & 8 & 1\\
      DS & DecimalString & 16 & 0\\
      DT & DateTime & 26 & 0\\
      FL & FloatingPointSingle & 4 & 1\\
      FD & FloatingPointDouble & 8 & 1\\
      IS & IntegerString & 12 & 0\\
      LO & LongStrong & 64 & 0\\
      LT & LongText & 10240 & 0\\
      OB & OtherByteString & 0 & 0\\
      OW & OtherWordString & 0 & 0\\
      PN & PersonName & 64 & 0\\
      SH & ShortString & 16 & 0\\
      SL & SignedLong & 4 & 1\\
      SQ & SequenceOfItems & 0 & 0\\
      SS & SignedShort & 2 & 1\\
      ST & ShortText & 1024 & 0\\
      TM & Time & 16 & 0\\
      UI & UniqueIdentifierUID & 64 & 0\\
      UL & UnsignedLong & 4 & 1\\
      UN & Unknown & 0 & 0\\
      US & UnsignedShort & 2 & 1\\
      UT & UnlimitedText & 0 & 0\\
      \hline
    \end{tabular}
  \end{center}
  \label{tab:VR}
  \caption{Value representations in the DICOM standard.}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

All attributes in the DICOM standard require different data types for
correct representation.  These are known as value representations
(VRs) in DICOM.  There are 27 such VRs defined, and listed in
Table~\ref{tab:VR}.  Detailed explanations of these data types are
provided in the Section~6.2 (part~5) of the DICOM standard
(\url{http://medical.nema.org}).  The first column provides the
two-character string that is present in each entry of the header field
and the second column provides a descriptive name for the abbreviated
code.  The third column provides the maximum length of the data
associated with the VR (in bytes).  The fourth column is not used in
the current implementation of the package.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\begin{verbatim}
Data element with explicit VR of OB, OF, OW, SQ, UT or UN:

+-----------------------------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 |
+----+----+----+----+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<VR----->|<0x0000->|<Length----------->|<Value->

Data element with explicit VR other than as shown above:

+---------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<VR----->|<Length->|<Value->

Data element with implicit VR:

+---------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<Length----------->|<Value->
\end{verbatim}
\caption{Byte ordering for a single (group,element) tag in the DICOM
  standard.  Explicit VRs store the VR as text characters in two
  bytes.  More information is provided in Section~7, Part 3.5-2009.}
\label{fig:group-element}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The DICOM Header}

Accessing the information stored in a single DICOM file is provided
using the \code{dicomInfo} function.  The basic structure of the
resulting object is a list with two elements: the DICOM header
(\code{hdr}) and the DICOM image (\code{img}).  The header information
is organized in a data frame with six columns and an unknown number of
rows depending on the input parameters.

<<DICOM Abdo 01>>=
abdo <- dicomInfo(system.file("dcm/Abdo.dcm", package="oro.dicom"))
names(abdo)
abdo$hdr[1:5,]
abdo$hdr[nrow(abdo$hdr)-4:0,]
@ 

The ordering of the rows is identical to the ordering in the original
DICOM file.  Hence, the first five tags in the DICOM header of
\code{Abdo.dcm} are: GroupLength, FileMetaInformationVersion,
MediaStorageSOPClassUID, MediaStorageSOPInstanceUID and
TransferSyntaxUID.  The last five tags in the DICOM header are also
shown, with the very last tag indicating the start of the image data
for that file and the number of bytes (131072) involved.  When
additional tags in the DICOM header information are queried

<<DICOM Abdo 02>>=
abdo$hdr$value[abdo$hdr$name == "BitsAllocated"]
abdo$hdr$value[abdo$hdr$name == "Rows"]
abdo$hdr$value[abdo$hdr$name == "Columns"]
@ 

it is clear that the data are consistent with the header information
in terms of the number of bytes ($256\times256\times2=131072$).

The first five columns are taken directly from the DICOM header
information (\code{group}, \code{element}, \code{code}, \code{length}
and \code{value}) or inferred from that information (\code{name}).
Note, the (\code{group},\code{element}) values are stored as character
strings even though they are hexadecimal numbers.  All aspects of the
data frame may be interrogated in \proglang{R} in order to extract
relevant information from the DICOM header; e.g.,
\code{"BitsAllocated"} as above.  The \code{sequence} column is used
to keep track of tags that are embedded in a fixed-length
SequenceItems tag or between a SequenceItem-SequenceDelimitationItem
pair.

When multiple DICOM files are located in a single directory, or spread
across multiple directories, one may use the function
\code{dicomSeparate} (applied here to the directory \code{hk-40}).

<<DICOM HK40 01>>=
hk40 <- dicomSeparate(system.file("hk-40", package="oro.dicom"))
c(length(hk40$hdr), length(hk40$img))
@ 

The object associated with \code{dicomSeparate} is now a nested set of
lists, where the \code{hdr} element is a list of data frames and the
\code{img} element is a list of matrices.  These two lists are
associated in a pairwise sense; i.e., \code{hdr[[1]]} is the header
information for the image \code{img[[1]]}.  Default parameters
\code{recursive = TRUE} and \code{pixelData = TRUE} (which is actually
an input parameter for \code{dicomInfo}) allow the user to search down
all possible subdirectories and upload the image in addition to the
header information, respectively.  Also, by default all files are
treated as DICOM files unless the \code{exclude} parameter is set to
the unwanted file extension; e.g., \code{exclude = "xml"}.

\subsection{The DICOM Image}

Most DICOM files involve a single slice from an acquisition -- the
image.  A noteable exception is the Siemens MOSAIC format (addressed
in Section~\ref{sec:mosaic}).  Going back to the \code{Abdo.dcm}
example, the image is accessed via

<<figure1-png,echo=FALSE,results=hide>>=
png(filename="dicom_abdo.png", width=2*480, height=2*480, bg="black")
par(mar=rep(0,4))
@ 
<<figure1-code>>=
image(t(abdo$img), col=grey(0:64/64), axes=FALSE, xlab="", ylab="")
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
#par(mar=c(5,4,4,2)+0.1)
@ 

where the transpose function is necessary for proper visualization of
the image.  Figure~\ref{fig:dicom_abdo} displays a coronal slice
through the abdomen from an MRI acquisition.  All formatting
information should accompany the image through the DICOM header, and
this information is utiilized as much as possible by \pkg{oro.dicom}
to simplify the manipulation of DICOM data.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \centering
  \includegraphics*[width=0.65\textwidth]{dicom_abdo.png}
  \caption{Coronal slice of the abdomen viewed in
    \textit{neurological} convention (left is right and right is
    left).}
  \label{fig:dicom_abdo}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The basic DICOM file structure does not encourage the analysis of
multi-dimensional imaging data (e.g., 3D or 4D) commonly acquired on
clinical scanners.  Hence, the \pkg{oro.dicom} package has been
developed to access DICOM files and facilitate their conversion to the
NIfTI or ANALYZE formats.  The conversion process requires the
\pkg{oro.nifti} package and will be outlined in
Section~\ref{sec:dicom2nifti}.

\subsubsection{Siemens MOSAIC Format}
\label{sec:mosaic}

Siemens multi-slice EPI (echo planar imaging) data may be collected as
a ``mosiac'' image; i.e., all slices acquired in a single TR
(repitition time) of a dynamic run are stored in a single DICOM file.
The images are stored in an $M{\times}N$ array of images.  The
function \code{create3D} will try to guess the number of images
embedded within the single DICOM file using the AcquisitionMatrix
field.  If this doesn't work, one may enter the $(M,N)$ doublet
explicitly.

<<DICOM Siemens 01>>=
fname <- file.path("dcm", "MR-sonata-3D-as-Tile.dcm")
dcm <- dicomInfo(system.file(fname, package="oro.dicom"))
dim(dcm$img)
dcmImage <- create3D(dcm, mosaic=TRUE)
dim(dcmImage)
@ 

<<DICOM Siemens 02,echo=FALSE,results=hide>>=
dcmNifti <- dicom2nifti(dcm, mosaic=TRUE, aux.file=fname)
png(filename="dcmImage.png", width=2*480, height=2*480, bg="black")
image(t(dcm$img), col=grey(0:64/64), axes=FALSE, xlab="", ylab="")
dev.off()
png(filename="dcmNifti.png", width=2*480, height=2*480, bg="black")
image(dcmNifti)
dev.off()
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics*[width=0.45\textwidth]{dcmImage.png} & 
      \includegraphics*[width=0.45\textwidth]{dcmNifti.png}\\
      \textbf{(a)} & \textbf{(b)}
    \end{tabular}
  \end{center}
  \caption{\textbf{(a)} Single MOSAIC image.  \textbf{(b)} Lightbox
    display of three-dimensional array of images.}
  \label{fig:mosaic}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Figure~\ref{fig:mosaic}a is taken from the raw DICOM file, in mosaic
format, and displayed with the default margins in \proglang{R}.
Figure~\ref{fig:mosaic}b is displayed after re-organizing the original
DICOM file into a 3D array and then converting it to NIfTI format.

\section[oro.nifti: NIfTI-1 Data Input/Output in R]{\pkg{oro.nifti}: NIfTI-1 Data Input/Output in \proglang{R}}

Although the industry standard for medical imaging data is DICOM,
another format has come to be heavily used in the image analysis
community.  The ANALYZE format was originally developed in conjunction
with an image processing system (of the same name) at the Mayo
Foundation.  An ANALYZE~7.5 format image is comprised of two files,
the ``.hdr'' and ``.img'' files, that contain information about the
acquisition and the acquisition itself, respectively.  A more recent
adaption of this format is known as NIfTI-1 and is a product of the
Data Format Working Group (DFWG) from the Neuroimaging Informatics
Technology Initiative (NIfTI; \url{http://nifti.nimh.nih.gov}).  The
NIfTI-1 data format is almost identical to the ANALYZE format, but
offers a few improvements
\begin{itemize}
  \item merging of the header and image information
    into one file (.nii)
  \item re-organization of the 348-byte fixed header into more
    relevant categories 
  \item possibility of extending the header information.
\end{itemize}


\subsection{The NIfTI Header}

The NIfTI header inherits its structure (348 bytes in length) from the
ANALYZE data format.  A copy of the file ANALYZE75.pdf has been
included in \pkg{oro.nifti} (accessed via
\code{system.file("doc/ANALYZE75.pdf", package="oro.dicom")}) since it
does not appear to be available from \url{www.mayo.edu} any longer.
The last four bytes in the NIfTI header correspond to the ``magic''
field and denote whether or not the header and image are contained in
a single file (\code{magic = "n+1\textbackslash{}0"}) or two separate
files (\code{magic = "ni1\textbackslash{}0"}), the latter being
identical to the structure of the ANALYZE data format.  The NIfTI data
format added an additional four bytes to allow for ``extensions'' to
the header.  By default these four bytes are set to zero.

The first example of reading in, and displaying, medical imaging data
in NIfTI format \texttt{avg152T1\_LR\_nifti.nii.gz} was obtained from
the NIfTI website (\url{http://nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the commands

<<mniLR_nifti>>=
fname <- file.path("nifti", "mniLR.nii.gz")
(mniLR <- readNIfTI(system.file(fname, package="oro.nifti")))
aux.file(mniLR)
descrip(mniLR)
@ 

produces an S4 \code{"nifti"} object (or \code{"niftiAuditTrail"} if
the audit trail option is set).  Two accessor functions are also
provider : \code{aux.file} and \code{descrip}.  The former is used to
access the original name of the file (if it has been provided) and the
latter is the name of a valid NIfTI header field used to hold a
``description'' (up to 80~characters in length).

\subsection{The NIfTI Image}

Image information begins, in a single NIfTI file (\code{magic =
  "n+1\textbackslash{}0"}), after the first 352 bytes.  If header
extensions are used, then the image information is pushed further in
the byte stream. \textbf{[MORE!]}

<<figure1-png,echo=FALSE,results=hide>>=
png(filename="mniLR.png", width=2*480, height=2*480, bg="black")
@ 
<<figure1-code>>=
image(mniLR)
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data, with the default NIfTI axes,
and is displayed on a $10{\times}10$ grid of images
(Figure~\ref{fig:mniLR+mniRL}a).  Note, the \code{image} function has
been overloaded with the classes \code{nifti} and \code{anlz} in order
to display them with minimal user input.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics*[width=0.45\textwidth]{mniLR.png} &
      \includegraphics*[width=0.45\textwidth]{mniRL.png}\\
      \textbf{(a)} & \textbf{(b)}
    \end{tabular}
  \end{center}
  \caption{\textbf{(a)} Axial slices of MNI volume \code{mniLR\_nifti}
    stored in the \emph{radiological} convention (right-is-right), but
    displayed in the \emph{neurological} convention (right-is-left).
    \textbf{(b)} Axial slices of MNI volume \code{mniRL\_nifti} stored
    and displayed in the \emph{neurological} convention.}
  \label{fig:mniLR+mniRL}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The second example of reading in, and displaying, medical imaging data
in NIfTI format \texttt{avg152T1\_RL\_nifti.nii.gz} was also obtained
from the NIfTI website (\url{http://nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the commands

<<mniRL_nifti>>=
fname <- file.path("nifti", "mniRL.nii.gz")
(mniRL <- readNIfTI(system.file(fname, package="oro.nifti")))
@ 
<<figure2-png,echo=FALSE,results=hide>>=
png(filename="mniRL.png", width=2*480, height=2*480, bg="black")
@ 
<<figure2-code>>=
image(mniRL)
<<figure2-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data that may be displayed in a
$10{\times}10$ grid of images (Figure~\ref{fig:mniLR+mniRL}b).  The
two sets of data in Figure~\ref{fig:mniLR+mniRL} are stored in two
different orientations, commonly referred to as \emph{radiological}
and \emph{neurological}.  The radiological convention is where ``right
is right'' and one is essentially looking through the subject.  The
neurological convention is where ``right is left'' and one is looking
at the subject.

\subsection{A Note on Axes and Orientation}

The NIfTI format contains an implicit generalized spatial
transformation from the data co-ordinate system $(i,j,k)$ into a
real-space ``right-handed'' co-ordinate system.  In this real-space
system, the $(x,y,z)$ axes are \emph{usually} set such that $x$
increases from left to right, $y$ increases from posterior to anterior
and $z$ increases from inferior to superior.

At this point in time the \pkg{oro.nifti} package cannot apply an
arbitrary transform to the imaging data into $(x,y,z)$ space -- such a
transform may require non-integral indices and interpolation steps.
The package does accommodate straightforward transformations of
imaging data; e.g., setting the $x$-axis to increase from right to
left (the neurological convention).  Future versions of
\pkg{oro.nifti} will attempt to address more complicated spatial
transformations.

\subsection{NIfTI and ANALYZE Data in S4}

A major improvement in the \pkg{oro.nifti} package is the fact that
standard medical imaging formats are stored in unique classes under
the S4 system \citep{chambers:2008}.  Essentially, NIfTI and ANALYZE
data are stored as multi-dimensional arrays with extra slots created
that capture the format-specific header information.  The NIfTI class
also has the ability to read and write extensions that conform to the
NIfTI data format.  Customized printing and validity-checking
functions are available to the user and every attempt has been made to
ensure that the information from the multi-dimensional array is in
agreement with the header values.

\subsection{Audit Trail}

Following on from the S4 implementation of both the NIfTI and ANALYZE
data formats, the ability to extend the NIfTI data format header is
utilized in the \pkg{oro.nifti} package.  First, extensions are
properly handled when reading and writing NIfTI data.  Second, users
are allowed to add extensions to newly-created NIfTI objects using
various functions and the \pkg{XML} package \citep{XML}.  Third, by
default all operations that are performed on a NIfTI object will
generate what we call an \emph{audit trail} that consists of an
XML-based log.  Each log entry contains information not only about the
function applied to the NIfTI object, but also various system-level
information; e.g., version of \proglang{R}, user name, date, time,
etc.  When writing NIfTI-class objects to disk, the XML-based NIfTI
extension is converted into plain text and saved appropriately (ecode
= 6).  The user may control the tracking of data manipulation via the
audit trail using a global option.  For example, please use the command

<<niftiAuditTrail,eval=FALSE>>=
options(niftiAuditTrail=FALSE)
@

to turn off the ``audit trail'' option in \pkg{oro.nifti}.
Table~\ref{tab:mniLR} displays output from the accesor function
\code{audit.trail(mniLR)}, the XML-based audit trail that is stored as
a NIfTI header extension.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{sidewaystable}
  \caption{XML-based audit trail obtained via \code{audit.trail(mniLR)}.}
  \label{tab:mniLR}
  \vspace{3mm}
  \centering
  \begin{tabular}{p{22cm}}
<<NIfTI audit.trail 01>>=
audit.trail(mniLR)
@
  \end{tabular}
\end{sidewaystable}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Visualization}

Interactive visualization of multidimensional arrays, stored in NIfTI
or ANALYZE format, is best performed outside of \proglang{R} at this
point in time.  Popular viewers, especially for brain imaging, are
\begin{itemize}
\item FSLView (\url{http://www.fmrib.ox.ac.uk/fsl/fslview/}),
\item MRIcron (\url{http://cabiatl.com/mricron/}).
\end{itemize}
The \pkg{mritc} package provides interactive visualization of
ANALYZE/NIfTI data using a Tcl/Tk interface \citep{mritc}.

\subsection{Examples from the NIfTI-1 DFWG}

\subsubsection{Simple Time-series or Multi-volume Image}

This is an example of reading in, and displaying, a four-dimensional
medical imaging data set in NIfTI format
\texttt{filtered\_func\_data.nii} obtained from the NIfTI website
(\url{http://nifti.nimh.nih.gov/nifti-1/}).  Successful execution of
the commands

<<filtered_func_data>>=
fname <- file.path("nifti", "ffd.nii.gz")
(ffd <- readNIfTI(system.file(fname, package="oro.nifti")))
@ 
<<figure3-png,echo=FALSE,results=hide>>=
png(filename="ffd.png", width=2*480, height=2*480, bg="black")
@ 
<<figure3-code>>=
image(ffd)
@ 
<<figure3-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \begin{center}
    \begin{tabular}{cc}
      \includegraphics*[width=0.45\textwidth]{ffd.png} &
      \includegraphics*[width=0.45\textwidth]{ffd_zstat1.png}\\
      \textbf{(a)} & \textbf{(b)}
    \end{tabular}
  \end{center}
  \caption{\textbf{(a)} Axial slices of the functional MRI ``volume''
    \code{filtered\_func\_data} from the first acquisition.
    \textbf{(b)} Axial slices of the functional MRI data with the
    statistical image overlayed.  The test statistics were thresholded
    at $|Z|\geq{5}$ for all voxels.}
  \label{fig:ffd+zstat1}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \begin{center}
    \includegraphics*[width=0.65\textwidth]{ffd_orthographic.png}
    \end{center}
  \caption{Orthographic display of the first volume from the
    functional MRI dataset \texttt{filtered\_func\_data}.  By default
    the mid-axial, mid-saggittal and mid-coronal planes are chosen.}
  \label{fig:ffd-orthographic}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

produces a four-dimensional (4D) array of imaging data that may be
displayed in a $5{\times}5$ grid of images
(Figure~\ref{fig:ffd+zstat1}a).  The first three dimensions are
spatial locations of the voxel (volume element) and the fourth
dimension is time.  An additional graphical display function has been
added for \code{nifti} and \code{anlz} objects that allows
orthographic displays.

<<figure3b-png,echo=FALSE,results=hide>>=
png(filename="ffd_orthographic.png", width=2*480, height=2*480, bg="black")
@ 
<<figure3b-code>>=
orthographic(ffd)
@ 
<<figure3b-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

\subsubsection{Statistical Image}

This is an example of reading in and displaying a statistical image so
that it may be overlayed on the EPI (echo planar imaging) data taken
from the functional MRI experiment.  The original NIfTI files,
\texttt{filtered\_func\_data.nii} and \texttt{zstat1.nii}, were
obtained from the NIfTI website
(\url{http://nifti.nimh.nih.gov/nifti-1/}).  Successful execution of
the command

<<zstat1>>=
fname <- file.path("nifti", "zstat1.nii.gz")
(zstat1 <- readNIfTI(system.file(fname, package="oro.nifti")))
@ 
<<figure4-png,echo=FALSE,results=hide>>=
png("ffd_zstat1.png", width=2*480, height=2*480, bg="black")
@ 
<<figure4-code>>=
overlay(ffd, ifelse(abs(zstat1) > 5, zstat1, NA), zlim.y=range(zstat1))
<<figure4-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of parameter estimates (essentially coefficients
from a linear regression performed at each voxel) that may be
overlayed on the original data for anatomical reference
(Figure~\ref{fig:ffd+zstat1}b).  The function \code{overlay} extends
the capabilities of displaying ``images'' by allowing one to add a
statistical image to an underlying structural image.

\section{Converting DICOM to NIfTI}
\label{sec:dicom2nifti}

The \pkg{oro.nifti} package requires incoming data to be in the
ANALYZE~7.5 or NIfTI formats.  Data acquisition and conversion from
DICOM must be performed by the user before the package \pkg{oro.nifti}
may be used to manipulate the imaging data.  Several standalone
software packages allow DICOM-to-NIfTI (or ANALYZE) conversion; e.g.,
\begin{itemize}
\item FreeSurfer (\url{http://surfer.nmr.mgh.harvard.edu}),
\item Xmedcon (\url{http://xmedcon.sourceforge.net}),
\item MRIConvert (\url{http://lnci.oregon.edu/\~jolinda/MRIConvert}).
\end{itemize}
This is by no means an exhaustive list of standalone software packages
available for DICOM conversion.  In addition there are several
\proglang{R} packages with the ability to process DICOM data
\begin{itemize}
\item \pkg{fmri} \citep{pol-tab:fmri}
\item \pkg{tractor.base} \citep{tractor.base} (part of the tractor
  project \url{http://code.google.com/p/tractor})
\end{itemize}
and facilitate their conversion to ANALYZE or NIfTI format.  However,
the \pkg{oro.dicom} and \pkg{oro.nifti} packages have been designed to
use as much information as possible from the metadata-rich DICOM
format and use that information in the construction of the NIfTI data
volume.

\subsection{Example}

<<DICOM2NIFTI HK40 01>>=
(hk40n <- dicom2nifti(hk40))
@ 
<<DICOM2NIFTI HK40 02,echo=FALSE,results=hide>>=
png("hk40n_image.png", width=2*480, height=2*480, bg="black")
image(hk40n)
dev.off()
png("hk40n_orthographic.png", width=2*480, height=2*480, bg="black")
orthographic(hk40n)
dev.off()
@ 
<<DICOM2NIFTI HK40 03,eval=FALSE>>=
image(hk40n)
orthographic(hk40n)
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htbp]
  \begin{center}
    \begin{tabular}{c}
    \includegraphics*[width=0.6\textwidth]{hk40n_image.png}\\
    \textbf{(a)}\\
    \includegraphics*[width=0.6\textwidth]{hk40n_orthographic.png}\\
    \textbf{(b)}
    \end{tabular}
  \end{center}
  \caption{\textbf{(a)} Lightbox display of three-dimensional array of
    images.  \textbf{(b)} Orthographic display of the same
    three-dimensional array (using the default settings for
    \code{orthographic}).}
  \label{fig:hk40n}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

Medical image analysis depends on the efficient manipulation and
conversion of DICOM data.  The \pkg{oro.dicom} and \pkg{oro.nifti}
packages have been developed to provide the user with a set of
functions that mask as many of the background details as possible
while still providing flexible and robust performance.  

The future of medical image analysis in \proglang{R} will benefit from
a unified view of the imaging data standards: DICOM, NIfTI and
ANALYZE.  The existence of a single package for handling imaging data
formats would facilitate interoperability between the ever increasing
number of \proglang{R} packages devoted to medical image analysis.  We
do not assume that the data structures in \pkg{oro.dicom} or
\pkg{oro.nifti} are best-suited for this purpose and we welcome an
open discussion around how best to provide this standardization to the
end user.

\section*{Acknowledgments}

The authors would like to thank...
 VS is supported by the LMUinnovative project BioMed-S: 
Analysis and Modelling of Complex Systems.

\bibliography{dicom_nifti}

\end{document}
