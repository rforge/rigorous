\documentclass[article,shortnames]{jss}

\usepackage{rotating}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Brandon Whitcher\\GlaxoSmithKline \And 
        Volker J. Schmid\\Ludwig-Maximilians Universit\"at M\"unchen \And
        Andrew Thornton\\Cardiff University}
\title{Working with the {DICOM} and {NIfTI} Data Standards in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Brandon Whitcher, Volker Schmid, Andrew Thornton} %% comma-separated
\Plaintitle{Working with the {DICOM} and {NIfTI} Data Standards in R} %% without formatting
\Shorttitle{{DICOM} and {NIfTI} in R} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{

Two packages are provided for the manipulation of medical imaging data
that conform to the DICOM standard or Analyze/NIfTI formats.  DICOM
data, from a single file or single directory or directory tree, may be
uploaded into \proglang{R} using basic data structures: a data frame
for the header information and a matrix for the image data.  A list
structure is used to organize multiple DICOM files.  The S4 class
framework is used to develop basic Analyze and NIfTI classes, where
NIfTI extensions may be used to augment the NIfTI class.  One example
of this is an XML-based ``audit trail'' that tracks the history of
operations applied to a dataset.  The conversion from DICOM to
Analyze/NIfTI is also possible.  The S4 classes have been developed to
provide a user-friendly interface to the Analyze/NIfTI data formats;
allowing easy data input, data output, image processing and
visualization.

}
\Keywords{keywords, comma-separated, not capitalized, \proglang{R}}
\Plainkeywords{keywords, comma-separated, not capitalized, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Brandon Whitcher\\
  GlaxoSmithKline\\
  Clinical Imaging Centre\\
  Hammersmith Hospital\\
  Du Cane Road\\
  London W12 0HS, United Kingdom\\
  E-mail: \email{bjw34032@users.sourceforge.net}\\
  URL: \url{http://rigorousanalytics.blogspot.com/}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<preliminaries,echo=FALSE,results=hide>>=
library("oro.dicom")
library("bitops")
library("XML")
library("splines")
library("oro.nifti")
options(width=80)
options(prompt="R> ")
@

\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

\section[]{Introduction}

Medical imaging is well established in both the clinical and research
arenas with numerous equipment manufacturers supplying a wide variety
of modalities.  The DICOM standard was developed from earlier
standards and released in 1993.  It is the data format for clinical
imaging equipment, and other equipment that is beyond the scope of
this work.  The DICOM standard provides interoperability across
hardware, but was not designed to facilitate efficient data
manipulation and image processing.

The Analyze format was developed at the Mayo Clinic (in the 1990s) to
store multidimensional biomedical images.  It is fundamentally
different from the DICOM standard since it groups all images from a
single acquisition (typically three- or four-dimensional) into a pair
of binary files, one containing header information and one containing
the image information.  The DICOM standard groups the header and image
information, typically a single two-dimensional image, into a single
file.  Hence, a single acquisition will contain multiple DICOM files
but only a pair of Analyze files.

The NIfTI format was developed in the early 2000s by the DFWG (Data
Format Working Group) in an effort to improve upon the Analyze format.
The resulting NIfTI-1 format adheres to the basic header/image
combination from the Analyze format, but allows the pair of files to
be combined into a single file and re-defines the header fields.

The material presented here provides users with a method of
interacting with DICOM, Analyze and NIfTI files in \proglang{R}.
Real-world datasets, that are publically available, are used to
illustrate the basic functionality of the two packages:
\pkg{oro.dicom} and \pkg{oro.nifti}.  Major featuers include data
input/output and conversion from DICOM to Analyze/NIfTI.

\section[oro.dicom: DICOM Data Input/Output in R]{\pkg{oro.dicom}: DICOM Data Input/Output in \proglang{R}}

The industry standard format, for data acquired using a clinical
imaging device, is DICOM (Digital Imaging and Communications in
Medicine; \url{http://medical.nema.org}).  The DICOM ``standard'' is
very broad and complex.  Roughly speaking each DICOM-compliant file is
a collection of fields organized into two four-byte sequences
(group,element) that are represented as hexadecimal numbers and form a
tag.  The (group,element) combination establishes what type of
information is forthcoming in the file.  There is no fixed number of
bytes for a DICOM header.  The final (group,element) tag should be the
``data'' tag (7FE0,0010), such that all subsequent information is
related to the image(s).

\begin{table}
  \begin{center}
    \begin{tabular}{llrr}
      \hline
      \textbf{Code} & \textbf{Name} & \textbf{Bytes} & \textbf{Fixed}\\
      \hline\\
      AE & ApplicationEntity & 16 & 0\\
      AS & AgeString & 4 & 1\\
      AT & AttributeTag & 4 & 1\\
      CS & CodeString & 16 & 0\\
      DA & Date & 8 & 1\\
      DS & DecimalString & 16 & 0\\
      DT & DateTime & 26 & 0\\
      FL & FloatingPointSingle & 4 & 1\\
      FD & FloatingPointDouble & 8 & 1\\
      IS & IntegerString & 12 & 0\\
      LO & LongStrong & 64 & 0\\
      LT & LongText & 10240 & 0\\
      OB & OtherByteString & 0 & 0\\
      OW & OtherWordString & 0 & 0\\
      PN & PersonName & 64 & 0\\
      SH & ShortString & 16 & 0\\
      SL & SignedLong & 4 & 1\\
      SQ & SequenceOfItems & 0 & 0\\
      SS & SignedShort & 2 & 1\\
      ST & ShortText & 1024 & 0\\
      TM & Time & 16 & 0\\
      UI & UniqueIdentifierUID & 64 & 0\\
      UL & UnsignedLong & 4 & 1\\
      UN & Unknown & 0 & 0\\
      US & UnsignedShort & 2 & 1\\
      UT & UnlimitedText & 0 & 0\\
      \hline
    \end{tabular}
  \end{center}
  \label{tab:VR}
  \caption{Value representations in the DICOM standard.}
\end{table}

All attributes in the DICOM standard require different data types for
correct representation.  These are known as value representations
(VRs) in DICOM.  There are 27 such VRs defined, and listed in
Table~\ref{tab:VR}.  Detailed explanations of these data types are
provided in the Section~6.2 (part~5) of the DICOM standard
(\url{http://medical.nema.org}).  The first column provides the
two-character string that is present in each entry of the header field
and the second column provides a descriptive name for the abbreviated
code.  The third column provides the maximum length of the data
associated with the VR (in bytes).  The fourth column is not used in
the current implementation of the package.

\begin{figure}
\begin{verbatim}
Data element with explicit VR of OB, OF, OW, SQ, UT or UN:

+-----------------------------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 |
+----+----+----+----+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<VR----->|<0x0000->|<Length----------->|<Value->

Data element with explicit VR other than as shown above:

+---------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<VR----->|<Length->|<Value->

Data element with implicit VR:

+---------------------------------------+
|  0 |  1 |  2 |  3 |  4 |  5 |  6 |  7 |
+----+----+----+----+----+----+----+----+
|<Group-->|<Element>|<Length----------->|<Value->
\end{verbatim}
\label{fig:group-element}
\caption{Byte ordering for a single (group,element) tag in the DICOM
  standard.  Explicit VRs store the VR as text characters in two
  bytes.  More information is provided in Section~7, Part 3.5-2009.}
\end{figure}



\subsection[]{The DICOM Header}

Accessing the information stored in a single DICOM file is enabled
using the \code{dicomInfo} function.  The basic structure of the
resulting object is a list with two elements: the DICOM header
(\code{hdr}) and the DICOM image (\code{img}).  The header information
is organized in a data frame with six columns and an unknown number of
rows depending on the input parameters.

<<DICOM Abdo 01>>=
abdo <- dicomInfo(system.file("dcm/Abdo.dcm", package="oro.dicom"))
names(abdo)
abdo$hdr[1:5,]
abdo$hdr[nrow(abdo$hdr)-4:0,]
@ 

The ordering of the rows is identical to the ordering in the original
DICOM file.  Hence, the first five tags in the DICOM header of
\code{Abdo.dcm} are: ``GroupLength'', ``FileMetaInformationVersion'',
``MediaStorageSOPClassUID'', ``MediaStorageSOPInstanceUID'' and
``TransferSyntaxUID''.  The last five tags in the DICOM header are
also shown, with the very last tag indicating the start of the image
data for that file and the number of bytes (131072) involved.  When
additional tags in the DICOM header information are queried

<<DICOM Abdo 02>>=
abdo$hdr$value[abdo$hdr$name == "BitsAllocated"]
abdo$hdr$value[abdo$hdr$name == "Rows"]
abdo$hdr$value[abdo$hdr$name == "Columns"]
@ 

it is clear that the data are consistent with the header information
in terms of number of bytes ($256\times256\times2=131072$).

The first five columns are taken directly from the DICOM header
information (\code{group}, \code{element}, \code{code}, \code{length}
and \code{value}) or inferred from that information (\code{name}).
Note, the (\code{group},\code{element}) values are stored as character
strings even though they are hexadecimal numbers.  All aspects of the
data frame may be interrogated in \proglang{R} in order to extract
relevant information from the DICOM header; e.g.,
\code{"BitsAllocated"} as above.

When multiple DICOM files are located in a single directory, or spread
across multiple directories in a tree, the function
\code{dicomSeparate} is used.  

<<DICOM HK40 01>>=
hk40 <- dicomSeparate(system.file("hk-40", package="oro.dicom"))
c(length(hk40$hdr), length(hk40$img))
@ 

The object associated with \code{dicomSeparate} is now a nested set of
lists, where the \code{hdr} is a list of data frames and the
\code{img} is a list of matrices.  These two lists are associated in a
pairwise sense; i.e., \code{hdr[[1]]} is the header information for
the image \code{img[[1]]}.  Default parameters \code{recursive = TRUE}
and \code{pixelData = TRUE} (which is actually an input parameter for
\code{dicomInfo}) allow the user to search down all possible
subdirectories and upload the image in addition to the header
information, respectively.  Also, by default all files are treated as
DICOM files unless the \code{exclude} parameter is set to the unwanted
file extension; e.g., \code{exclude = "xml"}.

\subsection[]{The DICOM Image}

Most DICOM files involve a single slice from an acquisition -- the
image.  A noteable exception is the Siemens MOSAIC format.  Going back to the \code{Abdo.dcm} example, the image is
accessed via 

<<figure1-png,echo=FALSE,results=hide>>=
png(filename="dicom_abdo.png", width=480, height=480, bg="black")
par(mar=rep(0,4))
@ 
<<figure1-code>>=
image(t(abdo$img), col=grey(0:64/64), axes=FALSE, xlab="", ylab="")
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
#par(mar=c(5,4,4,2)+0.1)
@ 

where the transpose function is necessary for proper visualization of
the image.  Figure~\ref{fig:dicom_abdo} displays a coronal slice
through the abdomen from an MRI acquisition.  All formatting
information should accompany the image through the DICOM header, and
this information is utiilized as much as possible by \pkg{oro.dicom}
to simplify the manipulation of DICOM data.  

\begin{figure}[!htbp]
  \centering
  \includegraphics*[width=0.5\textwidth]{dicom_abdo.png}
  \caption{Coronal slice of the abdomen viewed in
    \textit{neurological} convention (left is right and right is
    left).}
  \label{fig:dicom_abdo}
\end{figure}

The basic DICOM file structure does not encourage the analysis of
multi-dimensional imaging data (e.g., 3D or 4D) commonly acquired on
clinical scanners.  Hence, the \pkg{oro.dicom} package has been
developed to access DICOM files and facilitate their conversion to the
NIfTI or Analyze formats.  The conversion process requires the
\pkg{oro.nifti} package and will be outlined in
Section~\ref{sec:dicom2nifti}.

\subsubsection[]{Siemens MOSAIC Format}

Siemens multi-slice EPI (echo planar imaging) data may be collected as
a ``mosiac'' image; i.e., all slices acquired in a single TR
(repitition time) of a functional MRI run are stored in a single DICOM
file.  The images are stored in an $M{\times}N$ array of images.  The
function \code{create3D} will try to guess the number of images
embedded within the single DICOM file using the ``AcquisitionMatrix''
field.  If this doesn't work, one may enter the $(M,N)$ doublet
explicitly.

<<DICOM Siemens 01>>=
fname <- file.path("dcm", "MR-sonata-3D-as-Tile.dcm")
dcm <- dicomInfo(system.file(fname, package="oro.dicom"))
dim(dcm$img)
dcmImage <- create3D(dcm, mosaic=TRUE)
dim(dcmImage)
(dcmNifti <- dicom2nifti(dcm, mosaic=TRUE, aux.file=fname))
@ 

<<DICOM Siemens 02,echo=FALSE,results=hide>>=
png(filename="dcmImage.png", width=480, height=480, bg="black")
image(t(dcm$img), col=grey(0:64/64), axes=FALSE, xlab="", ylab="")
dev.off()
png(filename="dcmNifti.png", width=480, height=480, bg="black")
image(dcmNifti)
dev.off()
@ 

\begin{figure}[!htbp]
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{dcmImage.png}\\
    \textbf{(a)}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{dcmNifti.png}\\
    \textbf{(b)}
  \end{minipage}
  \label{fig:mosaic}
  \caption{\textbf{(a)} Single MOSAIC image.  \textbf{(b)} Lightbox
    display of three-dimensional array of images.}
\end{figure}

Figure~\ref{fig:mosaic}a is taken from the raw DICOM file, in mosaic
format, and displayed with the default margins
\code{par(mar=(5,4,4,2)+0.1)}.  Figure~\ref{fig:mosaic}b is displayed
after re-organizing the original DICOM file into a 3D array and then
converting it to NIfTI format.

\section[oro.nifti: NIfTI-1 Data Input/Output in R]{\pkg{oro.nifti}: NIfTI-1 Data Input/Output in \proglang{R}}

Although the industry standard for medical imaging data is DICOM,
another format has come to be heavily used in the image analysis
community.  The ANALYZE format was originally developed in conjunction
with an image processing system (of the same name) at the Mayo
Foundation.  An Anlayze (7.5) format image is comprised of two files,
the ``hdr'' and ``img'' files, that contain information about the
acquisition and the acquisition itself, respectively.  A more recent
adaption of this format is known as NIfTI-1 and is a product of the
Data Format Working Group (DFWG) from the Neuroimaging Informatics
Technology Initiative (NIfTI; \url{http://nifti.nimh.nih.gov}).  The
NIfTI-1 data format is almost identical to the ANALYZE format, but
offers a few improvements
\begin{itemize}
  \item merging of the header and image information
    into one file (.nii)
  \item re-organization of the 348-byte fixed header into more
    relevant categories 
  \item possibility of extending the header information.
\end{itemize}


\subsection[]{The NIfTI Header}

The NIfTI header inherits its structure (348 bytes in length) from the
ANALYZE data format (\code{system.file("doc/ANALYZE75.pdf",
  package="oro.dicom")}).  The last four bytes in teh NIfTI header
correspond to the ``magic'' field and denote whether or not the header
and image are contained in a single file (\code{magic =
  "n+1\textbackslash{}0"}) or two separate files (\code{magic =
  "ni1\textbackslash{}0"}), the latter being identical to the
structure of the ANALYZE data format.  The NIfTI data format added an
additional four bytes to allow for ``extensions'' to the header.  By
default these four bytes are set to zero.

The first example of reading in, and displaying, medical imaging data
in NIfTI format (\texttt{avg152T1\_LR\_nifti.nii.gz}) was obtained
from the NIfTI website (\url{http://nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the command

<<mniLR_nifti>>=
(mniLR <- readNIfTI(system.file("nifti/mniLR.nii.gz", package="oro.nifti")))
aux.file(mniLR)
descrip(mniLR)
@ 

produces an S4 \code{"nifti"} object (or \code{"niftiAuditTrail"} if
the audit trail option is set).  Two accessor functions are also shown
here: \code{aux.file} and \code{descrip}.  The former is used to
access the oriignal file name of the file (if it exists) and the
latter is the name of a valid NIfTI header field (up to 80~characters
in length).

\subsection[]{The NIfTI Image}

Image information begins, in a single NIfTI file (\code{magic =
  "n+1\textbackslash{}0"}), after the first 352 bytes.  If header
extensions are used, then the image information is pushed further in
the byte stream. \textbf{[MORE!]}

<<figure1-png,echo=FALSE,results=hide>>=
png(filename="mniLR.png", width=480, height=480, bg="black")
@ 
<<figure1-code>>=
image(mniLR)
@ 
<<figure1-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data, with the default NIfTI axes,
and is displayed on a $10{\times}10$ grid of images
(Figure~\ref{fig:mniLR+mniRL}a).  Note, the \code{image} function has
been overloaded with the classes \code{nifti} and \code{anlz} in order
to display them with minimal user input.

\begin{figure}[!htbp]
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{mniLR.png}\\
    \textbf{(a)}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{mniRL.png}\\
    \textbf{(b)}
  \end{minipage}
  \label{fig:mniLR+mniRL}
  \caption{\textbf{(a)} Axial slices of MNI volume \code{mniLR\_nifti}
    stored in \emph{radiological} convention, but displayed in
    \emph{neurological} convention.  \textbf{(b)} Axial slices of MNI
    volume \code{avg152T1\_RL\_nifti} stored in \emph{neurological}
    convention, but displayed in \emph{neurological} convention.}
\end{figure}

The second example of reading in, and displaying, medical imaging data
in NIfTI format (\code{avg152T1\_RL\_nifti.nii}) was also obtained
from the NIfTI website (\url{http://nifti.nimh.nih.gov/nifti-1/}).
Successful execution of the command

<<mniRL_nifti>>=
(mniRL <- readNIfTI(system.file("nifti/mniRL.nii.gz", package="oro.nifti")))
@ 
<<figure2-png,echo=FALSE,results=hide>>=
png(filename="mniRL.png", width=480, height=480, bg="black")
@ 
<<figure2-code>>=
image(mniRL)
<<figure2-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of the image data that may be displayed in a
$10{\times}10$ grid of images (Figure~\ref{fig:mniLR+mniRL}b).

\subsection[]{A Note on Axes and Orientation}

The NIfTI format contains an implicit generalized spatial
transformation from the data co-ordinate system $(i,j,k)$ into a
real-space ``right-handed'' co-ordinate system.  In this real-space
system, the $(x,y,z)$ axes are \emph{usually} set such that $x$
increases from left to right, $y$ increases from posterior to anterior
and $z$ increases from inferior to superior.

At this point in time the \pkg{oro.nifti} package cannot apply an
arbitrary transform to the imaging data into $(x,y,z)$ space -- such a
transform may require non-integral indices and interpolation steps.
The package does accommodate straightforward transformations of imaging
data; e.g., setting the $x$-axis to increase from right to left
(neurological).  Future versions of \pkg{oro.nifti} will attempt to
address more complicated transformations.

\subsection[]{NIfTI and ANALYZE data in S4}

A major improvement in the \pkg{oro.nifti} package is the fact that
standard medical imaging formats are stored in unique classes under
the S4 system \citep{chambers:2008}.  Essentially, NIfTI and ANALYZE
data are stored as multi-dimensional arrays with extra slots created
that capture the format-specific header information.  The NIfTI class
also has the ability to read and write extensions that conform to the
data format standard.  Customized printing and validity-checking
functions are available to the user and every attempt is made to
ensure that the information from the multi-dimensional array is in
agreement with the header values.

\subsection[]{Audit Trail}

Following on from the S4 implementation of both the NIfTI and Analyze
data formats, the ability to extend the NIfTI data format header is
utilized in the \pkg{oro.nifti} package.  First, extensions are
properly handled when reading and writing NIfTI data.  Second, users
are allowed to add extensions to newly-created NIfTI objects using
various functions and the \pkg{XML} package \citep{XML}.  Third, by
default all operations that are performed on a NIfTI object will
generate what we call an \emph{audit trail} that consists of an
XML-based log.  Each log entry contains information not only about the
function applied to the NIfTI object, but also various system-level
information; e.g., version of \proglang{R}, user name, date, time,
etc.  When writing NIfTI-class objects to disk, the XML-based NIfTI
extension is converted into plain text and saved appropriately (ecode
= 6).  The user may control the tracking of data manipulation via the
audit trail using a global option.  For example please use the command

<<niftiAuditTrail,eval=FALSE>>=
options(niftiAuditTrail=FALSE)
@

to turn off the ``audit trail'' option in \pkg{oro.nifti}.

Table~\ref{tab:mniLR} displays output from the accesor
function \code{audit.trail(mniLR)}, the XML-based audit trail that is
stored as a NIfTI header extension.

\begin{sidewaystable}
  \caption{XML-based audit trail obtained via \code{audit.trail(mniLR)}.}
  \label{tab:mniLR}
  \vspace{3mm}
  \centering
  \begin{tabular}{p{22cm}}
<<NIfTI audit.trail 01>>=
audit.trail(mniLR)
@
  \end{tabular}
\end{sidewaystable}

\subsection[]{Visualization}

Interactive visualization of multidimensional arrays, stored in NIfTI
or Analyze format, is best performed outside of \proglang{R} at this
point in time.  Popular viewers, especially for brain imaging, are
\begin{itemize}
\item FSLView (\url{http://www.fmrib.ox.ac.uk/fsl/fslview/})
\item MRIcroN (\url{http://www.sph.sc.edu/comd/rorden/MRicron/})
\end{itemize}

\subsection[]{Examples}

\subsubsection[]{Labelled LR Standard (MNI152) Images in NIfTI Format}

The first image (LR) is stored in radiological convention.  The second
image (RL) is stored in neurological convention.  Any NIfTI-1 compliant
viewing software should display these images identically.

\subsubsection[]{Simple Time-series or Multi-volume Image}

This is an example of reading in, and displaying, a four-dimensional
medical imaging data set in NIfTI format
(\texttt{filtered\_func\_data.nii}) obtained from the NIfTI website
(\url{http://nifti.nimh.nih.gov/nifti-1/}).  Successful execution of
the command

<<filtered_func_data>>=
(ffd <- readNIfTI(system.file("nifti/ffd.nii.gz", package="oro.nifti")))
@ 
<<figure3-png,echo=FALSE,results=hide>>=
png(filename="ffd.png", width=480, height=480, bg="black")
@ 
<<figure3-code>>=
image(ffd)
@ 
<<figure3-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a four-dimensional (4D) array of imaging data that may be
displayed in a $5{\times}5$ grid of images
(Figure~\ref{fig:ffd+zstat1}a).  The first three dimensions are
spatial locations of the voxel (volume element) and the fourth
dimension is time.

\begin{figure}[!htbp]
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{ffd.png}\\
    \textbf{(a)}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{ffd_zstat1.png}\\
    \textbf{(b)}
  \end{minipage}
  \label{fig:ffd+zstat1}
  \caption{\textbf{(a)} Axial slices of the functional MRI ``volume''
    \code{filtered\_func\_data} from the first acquisition.
    \textbf{(b)} Axial slices of the functional MRI data with the
    statistical image overlayed.  The test statistics were thresholded
    at $|Z|\geq{5}$ for all voxels.}
\end{figure}

%\begin{figure}[!htbp]
%  \centering
%  \includegraphics{ffd.png}
%  \caption{Axial slices of the functional MRI ``volume''
%  \texttt{filtered\_func\_data} from the first acquisition.}
%  \label{fig:ffd}
%\end{figure}

An additional graphical display function has been added for
\code{nifti} and \code{anlz} objects that allows orthographic displays.

<<figure3b-png,echo=FALSE,results=hide>>=
png(filename="ffd_orthographic.png", width=480, height=480, bg="black")
@ 
<<figure3b-code>>=
orthographic(ffd)
@ 
<<figure3b-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

\begin{figure}[!htbp]
  \centering
  \includegraphics*[width=0.5\textwidth]{ffd_orthographic.png}
  \caption{Orthographic display of the first volume from the
  functional MRI dataset \code{filtered\_func\_data}.  By default
  the mid-axial, mid-saggittal and mid-coronal planes are chosen.}
  \label{fig:ffd-orthographic}
\end{figure}

\subsubsection[]{Statistic Image}

This is an example of reading in and displaying a statistical image so
that it may be overlayed on the EPI (echo planar imaging) data taken
from the functional MRI experiment.  The original NIfTI files
(\texttt{filtered\_func\_data.nii} and \texttt{zstat1.nii}) were
obtained from the NIfTI website
(\url{http://nifti.nimh.nih.gov/nifti-1/}).  Successful execution of
the command

<<zstat1>>=
(zstat1 <- readNIfTI(system.file("nifti/zstat1.nii.gz", package="oro.nifti")))
@ 
<<figure4-png,echo=FALSE,results=hide>>=
png("ffd_zstat1.png", width=480, height=480, bg="black")
@ 
<<figure4-code>>=
overlay(ffd, ifelse(abs(zstat1) > 5, zstat1, NA), zlim.y=range(zstat1))
<<figure4-dev.off,echo=FALSE,results=hide>>=
dev.off()
@ 

produces a 4D array of parameter estimates (essentially coefficients
from a linear regression performed at each voxel) that may be
overlayed on the original data for anatomical reference
(Figure~\ref{fig:ffd+zstat1}b).  The function \code{overlay} extends
the capabilities of displaying ``images'' by allowing one to add a
statistical image to an underlying structural image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{figure}[!htbp]
%  \centering
%  \includegraphics{ffd_zstat1.png}
%  \caption{Axial slices of the functional MRI data with 
%  with the statistical image overlayed.  The test statistics were
%  thresholded at $|Z|\geq{5}$.}
%  \label{fig:zstat1}
%\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section[]{Converting DICOM to NIfTI}
\label{sec:dicom2nifti}

The \pkg{oro.nifti} package requires incoming data to be in the
ANALYZE~7.5 or NIfTI formats.  Data acquisition and conversion from
DICOM must be performed by the user before the package \pkg{oro.nifti}
may be used to manipulate the imaging data.  Several standalone
software packages allow DICOM-to-NIfTI (or ANALYZE) conversion; e.g.,
\begin{itemize}
\item FreeSurfer (\url{http://surfer.nmr.mgh.harvard.edu})
\item Xmedcon (\url{http://xmedcon.sourceforge.net})
\item MRIConvert (\url{http://lnci.oregon.edu/\~jolinda/MRIConvert})
\end{itemize}
This is by no means an exhaustive list of standalone software packages
available for DICOM conversion.  In addition there are several
\proglang{R} packages with the ability to process DICOM data
\begin{itemize}
\item \pkg{fmri}
\item \pkg{tractor.base} (part of the tractor project
  \url{http://code.google.com/p/tractor})
\end{itemize}
and facilitate their conversion to ANALYZE or NIfTI format.

\subsection[]{}

<<DICOM2NIFTI HK40 01>>=
(hk40n <- dicom2nifti(hk40))
@ 
<<DICOM2NIFTI HK40 02,echo=FALSE,results=hide>>=
png("hk40n_image.png", width=480, height=480, bg="black")
image(hk40n)
dev.off()
png("hk40n_orthographic.png", width=480, height=480, bg="black")
orthographic(hk40n)
dev.off()
@ 
<<DICOM2NIFTI HK40 03,eval=FALSE>>=
image(hk40n)
orthographic(hk40n)
@ 

\begin{figure}[!htbp]
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{hk40n_image.png}\\
    \textbf{(a)}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics*[scale=1]{hk40n_orthographic.png}\\
    \textbf{(b)}
  \end{minipage}
  \label{fig:hk40n}
  \caption{\textbf{(a)} .  \textbf{(b)} .}
\end{figure}

\section[]{Conclusion}

Medical image analysis depends on the efficient manipulation and
conversion of DICOM data.  The \pkg{oro.dicom} and \pkg{oro.nifti}
packages have been developed to provide the user with a set of
functions that mask as many of the background details as possible
while still providing flexible and robust performance.  

The future of medical image analysis in \proglang{R} will benefit from
a unified view of the imaging data standards: DICOM, NIfTI and
Analyze.  The existence of a single package for handling imaging data
formats would facilitate interoperability between the ever increasing
number of \proglang{R} packages devoted to medical image analysis.  We
do not assume that the data structures in \pkg{oro.dicom} or
\pkg{oro.nifti} are best-suited for this purpose and we welcome an
open discussion around how best to provide this standardization to the
end user.

\section*{Acknowledgments}

The authors would like to thank...

\bibliography{dicom_nifti}

\end{document}
